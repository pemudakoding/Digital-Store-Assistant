/**
 * Queue Monitor Command - Enhanced monitoring for queue performance and timeout issues
 */

import { queueHelpers } from "../../utils/queue.js";

export default async function queueMonitor(context) {
    try {
        const { messageService, from, msg, args } = context;
        
        // Handle undefined or empty args
        if (!args || !args.length) {
            const usage = `üîß *Queue Monitor Commands*

*Basic Monitoring:*
‚Ä¢ \`queuemonitor stats\` - Current queue statistics
‚Ä¢ \`queuemonitor health\` - Detailed health check
‚Ä¢ \`queuemonitor performance\` - Performance metrics
‚Ä¢ \`queuemonitor timeouts\` - Timeout analysis

*Management:*
‚Ä¢ \`queuemonitor clear\` - Clear all queues
‚Ä¢ \`queuemonitor pause\` - Pause all queues
‚Ä¢ \`queuemonitor resume\` - Resume all queues
‚Ä¢ \`queuemonitor emergency\` - Emergency stop
‚Ä¢ \`queuemonitor reset\` - Reset performance metrics
‚Ä¢ \`queuemonitor resetcircuit\` - Reset circuit breaker

*Examples:*
‚Ä¢ \`queuemonitor stats\`
‚Ä¢ \`queuemonitor performance\``;

            return await messageService.reply(from, usage, msg);
        }

        
        const action = args[0]?.toLowerCase();

        switch (action) {
            case 'stats':
                return await showQueueStats(context);
            case 'health':
                return await showQueueHealth(context);
            case 'performance':
                return await showPerformanceMetrics(context);
            case 'timeouts':
                return await showTimeoutAnalysis(context);
            case 'clear':
                return await clearAllQueues(context);
            case 'pause':
                return await pauseAllQueues(context);
            case 'resume':
                return await resumeAllQueues(context);
            case 'emergency':
                return await emergencyStop(context);
            case 'reset':
                return await resetMetrics(context);
            case 'resetcircuit':
                return await resetCircuitBreaker(context);
            default:
                return await messageService.reply(from, 
                    `‚ùå Unknown action: ${action}\n\nUse \`queuemonitor\` without arguments to see available commands.`, msg);
        }

    } catch (error) {
        console.error('Queue monitor error:', error);
        return await context.messageService.reply(context.from, 
            "‚ùå Gagal menjalankan queue monitor. Silakan coba lagi.", context.msg);
    }
}

async function showQueueStats(context) {
    const { messageService, from, msg } = context;
    
    try {
        const queueModule = await import("../../utils/queue.js");
        const stats = queueModule.default.getQueueStats();
        
        let statsMessage = `üìä *Queue Statistics*\n\n`;
        
        Object.entries(stats).forEach(([queueName, stat]) => {
            const statusIcon = stat.size > 20 ? 'üî¥' : stat.size > 10 ? 'üü°' : 'üü¢';
            statsMessage += `${statusIcon} *${queueName.charAt(0).toUpperCase() + queueName.slice(1)} Queue*\n`;
            statsMessage += `   ‚Ä¢ Size: ${stat.size}\n`;
            statsMessage += `   ‚Ä¢ Pending: ${stat.pending}\n\n`;
        });
        
        return await messageService.reply(from, statsMessage, msg);
    } catch (error) {
        console.error('Queue stats error:', error);
        return await messageService.reply(from, "‚ùå Gagal mengambil statistik queue.", msg);
    }
}

async function showQueueHealth(context) {
    const { messageService, from, msg } = context;
    
    try {
        const health = await queueHelpers.healthCheck();
        
        let healthMessage = `üè• *Queue Health Check*\n\n`;
        
        // Add circuit breaker status
        const queueModule = await import("../../utils/queue.js");
        const circuitBreakerStatus = queueModule.circuitBreaker || null;
        
        if (circuitBreakerStatus) {
            const breakerIcon = circuitBreakerStatus.isOpen ? 'üî¥' : 'üü¢';
            healthMessage += `üîå *Circuit Breaker*\n`;
            healthMessage += `   ‚Ä¢ Status: ${breakerIcon} ${circuitBreakerStatus.isOpen ? 'OPEN (Bypass Mode)' : 'CLOSED (Normal)'}\n`;
            healthMessage += `   ‚Ä¢ Failures: ${circuitBreakerStatus.failureCount}/${circuitBreakerStatus.threshold}\n`;
            if (circuitBreakerStatus.isOpen) {
                const resetIn = Math.max(0, circuitBreakerStatus.resetTime - (Date.now() - circuitBreakerStatus.lastFailure));
                healthMessage += `   ‚Ä¢ Reset in: ${Math.ceil(resetIn / 1000)}s\n`;
            }
            healthMessage += '\n';
        }
        
        Object.entries(health).forEach(([queueName, healthData]) => {
            const statusIcon = getStatusIcon(healthData.status);
            healthMessage += `${statusIcon} *${queueName.charAt(0).toUpperCase() + queueName.slice(1)}*\n`;
            healthMessage += `   ‚Ä¢ Status: ${healthData.status}\n`;
            healthMessage += `   ‚Ä¢ Size: ${healthData.size}\n`;
            healthMessage += `   ‚Ä¢ Pending: ${healthData.pending}\n`;
            healthMessage += `   ‚Ä¢ Paused: ${healthData.isPaused ? 'Yes' : 'No'}\n`;
            healthMessage += `   ‚Ä¢ Timeout: ${healthData.config.timeout / 1000}s\n\n`;
        });
        
        return await messageService.reply(from, healthMessage, msg);
    } catch (error) {
        console.error('Queue health error:', error);
        return await messageService.reply(from, "‚ùå Gagal mengambil health check queue.", msg);
    }
}

async function showPerformanceMetrics(context) {
    const { messageService, from, msg } = context;
    
    try {
        const metrics = queueHelpers.getPerformanceMetrics();
        
        let performanceMessage = `üìà *Performance Metrics*\n\n`;
        performanceMessage += `‚è±Ô∏è *Uptime Since:* ${new Date(metrics.uptimeSince).toLocaleString()}\n\n`;
        
        // Top operations by count
        const operations = Object.entries(metrics.operations);
        if (operations.length > 0) {
            performanceMessage += `üî¢ *Top Operations by Count:*\n`;
            operations
                .sort(([,a], [,b]) => b.count - a.count)
                .slice(0, 5)
                .forEach(([key, data]) => {
                    performanceMessage += `‚Ä¢ ${key}: ${data.count} ops (avg: ${Math.round(data.avgDuration)}ms)\n`;
                });
            performanceMessage += '\n';
        }
        
        // Slow operations
        const slowOps = Object.entries(metrics.slowOperations);
        if (slowOps.length > 0) {
            performanceMessage += `üêå *Slow Operations (>5s):*\n`;
            slowOps.slice(0, 5).forEach(([key, ops]) => {
                const recent = ops[ops.length - 1];
                performanceMessage += `‚Ä¢ ${key}: ${ops.length} times (last: ${Math.round(recent.duration/1000)}s)\n`;
            });
            performanceMessage += '\n';
        }
        
        // Timeouts
        const timeouts = Object.entries(metrics.timeouts);
        if (timeouts.length > 0) {
            performanceMessage += `‚è∞ *Timeout Errors:*\n`;
            timeouts.slice(0, 5).forEach(([key, count]) => {
                performanceMessage += `‚Ä¢ ${key}: ${count} timeouts\n`;
            });
        } else {
            performanceMessage += `‚úÖ *No timeout errors recorded*\n`;
        }
        
        return await messageService.reply(from, performanceMessage, msg);
    } catch (error) {
        console.error('Performance metrics error:', error);
        return await messageService.reply(from, "‚ùå Gagal mengambil performance metrics.", msg);
    }
}

async function showTimeoutAnalysis(context) {
    const { messageService, from, msg } = context;
    
    try {
        const metrics = queueHelpers.getPerformanceMetrics();
        
        let timeoutMessage = `‚è∞ *Timeout Analysis*\n\n`;
        
        const timeouts = Object.entries(metrics.timeouts);
        const slowOps = Object.entries(metrics.slowOperations);
        
        if (timeouts.length === 0) {
            timeoutMessage += `‚úÖ *No timeout errors in current session*\n\n`;
        } else {
            timeoutMessage += `üö® *Timeout Summary:*\n`;
            timeouts.forEach(([key, count]) => {
                timeoutMessage += `‚Ä¢ ${key}: ${count} timeouts\n`;
            });
            timeoutMessage += '\n';
        }
        
        if (slowOps.length > 0) {
            timeoutMessage += `üêå *Operations at Risk (>5s):*\n`;
            slowOps.forEach(([key, ops]) => {
                const avgDuration = ops.reduce((sum, op) => sum + op.duration, 0) / ops.length;
                timeoutMessage += `‚Ä¢ ${key}: ${ops.length} slow ops (avg: ${Math.round(avgDuration/1000)}s)\n`;
            });
            timeoutMessage += '\n';
        }
        
        timeoutMessage += `üí° *Recommendations:*\n`;
        if (timeouts.length > 0) {
            timeoutMessage += `‚Ä¢ Check server resources and network connection\n`;
            timeoutMessage += `‚Ä¢ Consider increasing timeout values\n`;
            timeoutMessage += `‚Ä¢ Review slow operations for optimization\n`;
        } else if (slowOps.length > 0) {
            timeoutMessage += `‚Ä¢ Monitor slow operations closely\n`;
            timeoutMessage += `‚Ä¢ Optimize operations taking >5 seconds\n`;
        } else {
            timeoutMessage += `‚Ä¢ System performance is optimal\n`;
        }
        
        return await messageService.reply(from, timeoutMessage, msg);
    } catch (error) {
        console.error('Timeout analysis error:', error);
        return await messageService.reply(from, "‚ùå Gagal menganalisis timeout.", msg);
    }
}

async function clearAllQueues(context) {
    const { messageService, from, msg } = context;
    
    try {
        const queueModule = await import("../../utils/queue.js");
        queueModule.default.clearAllQueues();
        
        return await messageService.reply(from, "‚úÖ Semua queue berhasil dibersihkan.", msg);
    } catch (error) {
        console.error('Clear queues error:', error);
        return await messageService.reply(from, "‚ùå Gagal membersihkan queue.", msg);
    }
}

async function pauseAllQueues(context) {
    const { messageService, from, msg } = context;
    
    try {
        const queueModule = await import("../../utils/queue.js");
        queueModule.default.pauseAllQueues();
        
        return await messageService.reply(from, "‚è∏Ô∏è Semua queue berhasil dijeda.", msg);
    } catch (error) {
        console.error('Pause queues error:', error);
        return await messageService.reply(from, "‚ùå Gagal menjeda queue.", msg);
    }
}

async function resumeAllQueues(context) {
    const { messageService, from, msg } = context;
    
    try {
        const queueModule = await import("../../utils/queue.js");
        queueModule.default.resumeAllQueues();
        
        return await messageService.reply(from, "‚ñ∂Ô∏è Semua queue berhasil dilanjutkan.", msg);
    } catch (error) {
        console.error('Resume queues error:', error);
        return await messageService.reply(from, "‚ùå Gagal melanjutkan queue.", msg);
    }
}

async function emergencyStop(context) {
    const { messageService, from, msg } = context;
    
    try {
        const queueModule = await import("../../utils/queue.js");
        queueModule.default.emergencyStop();
        
        return await messageService.reply(from, "üõë Emergency stop berhasil dilakukan. Semua queue dihentikan dan dibersihkan.", msg);
    } catch (error) {
        console.error('Emergency stop error:', error);
        return await messageService.reply(from, "‚ùå Gagal melakukan emergency stop.", msg);
    }
}

async function resetMetrics(context) {
    const { messageService, from, msg } = context;
    
    try {
        queueHelpers.resetPerformanceMetrics();
        
        return await messageService.reply(from, "üîÑ Performance metrics berhasil direset.", msg);
    } catch (error) {
        console.error('Reset metrics error:', error);
        return await messageService.reply(from, "‚ùå Gagal mereset metrics.", msg);
    }
}

async function resetCircuitBreaker(context) {
    const { messageService, from, msg } = context;
    
    try {
        const { circuitBreaker } = await import("../../utils/queue.js");
        
        const wasOpen = circuitBreaker.isOpen;
        circuitBreaker.isOpen = false;
        circuitBreaker.failureCount = 0;
        circuitBreaker.lastFailure = 0;
        
        const statusMessage = wasOpen 
            ? "üîÑ Circuit breaker berhasil direset dari status OPEN ke CLOSED. Queue operations restored!"
            : "üîÑ Circuit breaker direset (sudah dalam status CLOSED).";
        
        return await messageService.reply(from, statusMessage, msg);
    } catch (error) {
        console.error('Reset circuit breaker error:', error);
        return await messageService.reply(from, "‚ùå Gagal mereset circuit breaker.", msg);
    }
}

function getStatusIcon(status) {
    switch (status) {
        case 'healthy': return 'üü¢';
        case 'busy': return 'üü°';
        case 'warning': return 'üü†';
        case 'critical': return 'üî¥';
        case 'paused': return '‚è∏Ô∏è';
        default: return '‚ö™';
    }
} 